import { AppEvent } from '../AppEvent/AppEvent';
import { Command, CommandResult } from '../Command/Command';
import { fail } from '../Result/Result';
import { deepCopy } from '../Utility';

/**
 * An aggregate is a single-unit entity composed by a series of state-changing events.
 * With each new event added to the aggregate the state of the entity changes.
 *
 * Usually in practice, a command is applied to an aggregate which then produces one or more events.
 * The current state of the entity is populated (and can be re-hydrated) by sequential
 * application of the event stream.
 *
 * In other words, a series of events <E> are reduced to a
 * snapshot that is the current state of the object <S>.
 *
 * @param <E> The events that are the constituents of the aggregate
 * @param <S> The interface that represents the current state of the aggregate
 */
export class Aggregate < E extends AppEvent < string, any >, S > {
    /**
     * A unique identifier for the aggregate
     */
    protected id: string;
    /**
     * The initial state of the aggregate
     */
    protected initialState: S;
    /**
     * The current state of the aggregate
     */
    protected currentState: S;
    /**
     * The reducer used to calculate the state of the aggregate for each new event
     */
    protected reducer: (event: E, state: S) => S;
    /**
     * The events that constitute the aggregate
     */
    protected _events: E[] = [];

    constructor(aggregateID: string, initialState: S, reducer: (event: E, state: S) => S) {
        this.id = aggregateID;
		this.initialState = initialState;
        this.currentState = initialState;
        this.reducer = reducer;
    }

    /**
     * Add a new event to the aggregate and return the reduced state of the aggregate;
     * @param event an App Event
     * @returns the state of the aggregate
     */
    public addEvent(event: E): S {
        this._events.push(deepCopy(event));
        event.aggregateID = this.id;
        event.eventNumber = this._events.length;
        this.currentState = this.reduce(this.state, event);
        return this.currentState;
    }

	/**
     * Returns a readonly view of the event list to prevent external mutation.
     */
	public get events(): readonly E[] { return this._events; }

    /**
     * Determines changes to the aggregate's state. It uses the previous state + an event it receives to determine this change.
     * @param state a state of the Aggregate
     * @param event an App Event
     */
    public reduce(state: S, event: E): S {
        return this.reducer(event, state);
    }

    /**
     * Get the current state of the aggregate
     */
    public get state(): S {
        return this.currentState;
    }

	/**
	 * Reset the aggregate to the initial state and clear the event list
	 */
    reset() {
        this.currentState = this.initialState;
		this._events = [];
    }

	/**
	 * Executes the specified command, potentially generating and applying events to mutate the state of the aggregate.
	 *
	 * Upon successful execution of a command, events are generated and added to the {@link Aggregate}.
	 * These events are applied one at a time to mutate the state of the aggregate.
	 * In case of a command or reducer error, a failure {@link Result} is returned.
	 *
	 * @param {C} command - The command to execute.
	 * @returns {Result<E[], any, E[]>} A {@link Result} containing the events generated by the command, or an error.
	 */
    public executeCommand<C extends Command<CommandResult<E, C>>>(command: C): CommandResult<E, C> {
		let result;
		try {
			result = command.execute();
		} catch (reason: any) {
			console.error(reason);
			return fail(reason, { events: [], commands: [] });
		}

		if (result?.isSuccess) {
			const { commands, events } = result.value;
			const invalidOutput = !events.length && !commands?.length;
			if (invalidOutput) {
				return fail(
					new Error('Command completed with invaid output: no events and no follow up commands'),
					{ events: [], commands: [] });
			}
			const initialLength = this._events.length;
			const initialState = this.currentState;
			try {
				events.forEach(event => {
					this.addEvent(event);
				});
			} catch (reason: any) {
				// In case of an error, revert aggregate to its original state
				this._events = this._events.slice(0, initialLength);
				this.currentState = initialState;
				console.error(reason);
				return fail(reason, { events: [], commands: [] });
			}

			commands?.forEach((command) => {
				this.executeCommand(command);
			});
		}

        return result;
    }
}
