import { Aggregate } from './Aggregate';
import { AppEvent } from '../AppEvent/AppEvent';
import { Command } from '../Command/Command';
import { fail, Result } from '../Result/Result';

/**
 * The output value of a {@link CommandResult}.
 *
 * Contains the array of {@link AppEvent}s produced as well as
 * any follow-up {@link Command}s that should be executed afterwards.
 */
export type CommandOutput<E extends AppEvent<string, object>, C extends Command<Result<object, any, object>, any>> = {
	events: E[];
	commands: C[];
};

/**
 * A {@link CommandResult} represents the outcome of executing a {@link Command}.
 *
 * – On success, it returns a {@link CommandOutput} containing the events and commands.
 *
 * – On failure, it returns any error
 */
export type CommandResult<E extends AppEvent<string, object>, C extends Command<Result<object, any, object>, any>>
	= Result<CommandOutput<E, C>, any, CommandOutput<E, C>>

/**
 * The `CommandDrivenAggregate` class extends the functionality of an `Aggregate` by integrating
 * command handling. This class is responsible for encapsulating the logic for execution of commands that
 * can mutate the state of the aggregate and emit corresponding events as they are added.
 *
 * The class is designed to be generic, allowing for flexibility in the types of commands,
 * events, and states it can handle. This is achieved through generic type parameters.
 *
 * @template E - The type of the events that are constituents of the aggregate.
 * @template S - An object representing the current state of the aggregate.
 */
export class CommandDrivenAggregate<
    E extends AppEvent<string, any>,
    S extends object,
> extends Aggregate<E, S> {
    constructor(
        id: string,
        initialState: S,
        reducer: (event: E, state: S) => S
    ) {
        super(id, initialState, reducer);
    }

	/**
	 * Executes the specified command, potentially generating and applying events to mutate the state of the aggregate.
	 *
	 * Upon successful execution of a command, events are generated and added to the {@link Aggregate}.
	 * These events are applied one at a time to mutate the state of the aggregate.
	 * In case of a command or reducer error, a failure {@link Result} is returned.
	 *
	 * @param {C} command - The command to execute.
	 * @returns {Result<E[], any, E[]>} A {@link Result} containing the events generated by the command, or an error.
	 */
    public executeCommand<C extends Command<CommandResult<E, C>>>(command: C): CommandResult<E, C> {
		let result;
		try {
			result = command.execute();
		} catch (reason: any) {
			console.error(reason);
			return fail(reason, { events: [], commands: [] });
		}

		if (result?.isSuccess) {
			const { commands, events } = result.value;
			const invalidOutput = !events.length && !commands?.length;
			if (invalidOutput) {
				return fail(
					new Error('Command executed with but with invaid output: no events and no follow up commands'),
					{ events: [], commands: [] });
			}
			const initialLength = this._events.length;
			const initialState = this.currentState;
			try {
				events.forEach(event => {
					this.addEvent(event);
				});
			} catch (reason: any) {
				// In case of an error, revert aggregate to its original state
				this._events = this._events.slice(0, initialLength);
				this.currentState = initialState;
				console.error(reason);
				return fail(reason, { events: [], commands: [] });
			}

			commands?.forEach((command) => {
				this.executeCommand(command);
			});
		}

        return result;
    }
}
